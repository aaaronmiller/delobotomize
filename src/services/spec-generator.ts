import fs from 'fs/promises';
import path from 'path';
import { LLMProvider } from '../llm/provider-interface';

export interface SpecFile {
  name: string;
  path: string;
  format: 'speckit' | 'markdown' | 'custom';
  content: string;
  sections: SpecSection[];
}

export interface SpecSection {
  id: string;
  title: string;
  type: 'context' | 'architecture' | 'patterns' | 'commands' | 'examples' | 'validation';
  content: string;
  metadata?: any;
}

/**
 * Simplified spec file generator for better AI context
 */
export class SpecGenerator {
  constructor(private llmProvider: LLMProvider) {}

  /**
   * Generate spec files from project analysis
   */
  async generateSpecs(
    projectPath: string,
    projectStructure: { [file: string]: string }
  ): Promise<SpecFile[]> {
    const specs: SpecFile[] = [];

    // Detect existing spec format
    const existingSpecs = await this.detectExistingSpecs(projectPath);

    // Generate context.md for .claude directory
    const contextSpec = await this.generateContextSpec(
      projectPath,
      projectStructure,
      existingSpecs
    );
    if (contextSpec) {
      specs.push(contextSpec);
    }

    // Generate project-structure.md
    const structureSpec = await this.generateStructureSpec(
      projectPath,
      projectStructure
    );
    if (structureSpec) {
      specs.push(structureSpec);
    }

    // Generate patterns.md
    const patternsSpec = await this.generatePatternsSpec(projectPath);
    if (patternsSpec) {
      specs.push(patternsSpec);
    }

    return specs;
  }

  /**
   * Detect existing spec files
   */
  private async detectExistingSpecs(projectPath: string): Promise<{
    format: 'speckit' | 'markdown' | 'none' | 'mixed';
    files: string[];
  }> {
    const specPaths = [
      '.claude/context.md',
      '.claude/project-structure.md',
      '.claude/patterns.md',
      'spec/context.md',
      'spec/structure.md',
      'spec/patterns.md'
    ];

    const existing = [];
    for (const specPath of specPaths) {
      try {
        const fullPath = path.join(projectPath, specPath);
        await fs.access(fullPath);
        existing.push(specPath);
      } catch {
        // File doesn't exist
      }
    }

    const hasClaude = existing.some(p => p.includes('.claude/'));
    const hasSpec = existing.some(p => p.includes('spec/'));

    let format: 'speckit' | 'markdown' | 'none' | 'mixed' = 'none';
    if (hasClaude && !hasSpec) format = 'speckit';
    else if (hasSpec) format = 'markdown';
    else if (hasClaude && hasSpec) format = 'mixed';

    return { format, files: existing };
  }

  /**
   * Generate context.md spec file
   */
  private async generateContextSpec(
    projectPath: string,
    projectStructure: { [file: string]: string },
    existingSpecs: any
  ): Promise<SpecFile | null> {
    const contextPath = path.join(projectPath, '.claude', 'context.md');

    // Check if already exists and is valid
    if (existingSpecs.files.includes('.claude/context.md')) {
      try {
        const content = await fs.readFile(contextPath, 'utf-8');
        if (content.includes('# Project Context') && content.length > 100) {
          return null; // Already has valid context
        }
      } catch {
        // Continue to generation
      }
    }

    // Simple context generation
    const projectName = path.basename(projectPath);
    const fileCount = Object.keys(projectStructure).length;
    const hasTS = Object.keys(projectStructure).some(f => f.endsWith('.ts'));
    const hasJS = Object.keys(projectStructure).some(f => f.endsWith('.js'));
    const hasTests = Object.keys(projectStructure).some(f => f.includes('test') || f.includes('spec'));

    let language = 'JavaScript';
    if (hasTS) language = 'TypeScript';
    if (hasTests) language += ' with tests';

    const content = `# Project Context

**Project**: ${projectName}
**Language**: ${language}
**Files**: ${fileCount} total files
**Generated**: ${new Date().toISOString()}

## Overview

A ${language} project analyzed by Delobotomize. The build system includes:

- Source files in src/ directory
- ${hasTests ? 'Test files present' : 'No test directory detected'}

## Key Technologies

- ${language}
- Node.js Project
- File system operations

## Project Structure

Essential directories and their purposes:

- src/: Source code
- tests/: Test files (if present)
- docs/: Documentation (if present)

## Notes

This context file helps AI tools understand:
1. Project layout and organization
2. Language and framework being used
3. Where different types of files are located

*Generated by Delobotomize v0.1.0-alpha.1*
*Last updated: ${new Date().toISOString()}*
`;

    try {
      await fs.mkdir(path.dirname(contextPath), { recursive: true });
      await fs.writeFile(contextPath, content, 'utf-8');
      console.log('Generated: .claude/context.md');
    } catch (error) {
      console.error('Failed to generate context.md:', error);
    }

    return {
      name: 'context.md',
      path: contextPath,
      format: 'markdown',
      content,
      sections: [{
        id: 'context',
        title: 'Project Context',
        type: 'context',
        content
      }]
    };
  }

  /**
   * Generate project-structure.md
   */
  private async generateStructureSpec(
    projectPath: string,
    projectStructure: { [file: string]: string }
  ): Promise<SpecFile | null> {
    const structurePath = path.join(projectPath, '.claude', 'project-structure.md');

    const directories = new Set();
    const files = [];

    for (const [filePath] of Object.keys(projectStructure)) {
      if (filePath.includes('/')) {
        // It's a file
        files.push(filePath);
      } else {
        directories.add(filePath + '/');
      }
    }

    const content = `# Project Structure

**Project**: ${path.basename(projectPath)}
**Generated**: ${new Date().toISOString()}

## Directory Structure

${Array.from(directories).sort().map(dir => `- **${dir}/**: Main ${dir} directory`).join('\n')}

## Files

${files.map(file => `- **${file}**: Source file`).join('\n')}

*Generated by Delobotomize v0.1.0-alpha.1*
`;

    try {
      await fs.mkdir(path.dirname(structurePath), { recursive: true });
      await fs.writeFile(structurePath, content, 'utf-8');
      console.log('Generated: .claude/project-structure.md');
    } catch (error) {
      console.error('Failed to generate project-structure.md:', error);
    }

    return {
      name: 'project-structure.md',
      path: structurePath,
      format: 'markdown',
      content,
      sections: [{
        id: 'structure',
        title: 'Project Structure',
        type: 'architecture',
        content
      }]
    };
  }

  /**
   * Generate patterns.md
   */
  private async generatePatternsSpec(projectPath: string): Promise<SpecFile | null> {
    const patternsPath = path.join(projectPath, '.claude', 'patterns.md');

    const content = `# Code Patterns

**Project**: ${path.basename(projectPath)}
**Generated**: ${new Date().toISOString()}

## Common Patterns

This project uses standard JavaScript/TypeScript patterns:

- No AI-generated code detected in patterns.md being generated

## Best Practices

1. Always provide clear error messages
2. Use consistent naming conventions
3. Include proper error handling
4. Write tests for new features

*Generated by Delobotomize v0.1.0-alpha.1*
`;

    try {
      await fs.mkdir(path.dirname(patternsPath), { recursive: true });
      await fs.writeFile(patternsPath, content, 'utf-8');
      console.log('Generated: .claude/patterns.md');
    } catch (error) {
      console.error('Failed to generate patterns.md:', error);
    }

    return {
      name: 'patterns.md',
      path: patternsPath,
      format: 'markdown',
      content,
      sections: [{
        id: 'patterns',
        title: 'Code Patterns',
        type: 'patterns',
        content
      }]
    };
  }

  /**
   * Save generated spec files
   */
  async saveSpecs(specs: SpecFile[]): Promise<void> {
    for (const spec of specs) {
      if (spec) {
        const dir = path.dirname(spec.path);
        await fs.mkdir(dir, { recursive: true });
        await fs.writeFile(spec.path, spec.content, 'utf-8');
        console.log(`Generated: ${spec.name}`);
      }
    }
  }
}